* functions
** math functions
*** expt
    Exponentiation to a specific power.
    #+begin_src Lisp
    ;; 2^3 = 8
    (expt 2 3)
    #+end_src
*** exp
    Exponentiation with base e.
    #+begin_src Lisp
    ;; e^2 = 7.389056
    (exp 2)
    #+end_src
*** ash
    Arithmetic shift.
    #+BEGIN_SRC Lisp
    ;; shift left (=20)
    (ash 10 1)
    ;; shift right (=5)
    (ash 10 -1)
    #+END_SRC
*** oddp
    True if a number is odd
    #+begin_src Lisp
    ;; evaluates to T
    (oddp 1)
    ;; evaluates to nil
    (oddp 2)
    #+end_src
*** evenp
    True if a number is even
    #+begin_src Lisp
    ;; evaluates to nil
    (evenp 1)
    ;; evaluates to T
    (evenp 2)
    #+end_src
** definition functions
*** defparameter
    Allows the definition of global variables. By convention, global variable
    names are surrounded by *, known as /earmuffs/, so that they are easier
    to distinguish from local variables.
    
    Any value that was previously stored in the variable is overwritten. See
    [[defvar]] for a way to do it without overwriting.
    #+BEGIN_SRC Lisp
    ;; Defining a new parameter
    (defparameter *glob* 10)
    ;; Overwriting the parameter
    (defparameter *glob* 5)
    #+END_SRC
*** defvar
    Allows the definition of global variables, but does not overwrite previous
    values if they already exist.
    
    [[defparameter]] allows the overwriting of the value in global variables.
    #+BEGIN_SRC Lisp
    ;; Defining a new parameter
    (defvar *glob* 10)
    ;; attempting to overwrite (*glob* is still 5)
    (defvar *glob* 5)
    #+END_SRC
*** defun
    Allows the definition of a function.
    #+BEGIN_SRC Lisp
    (defun func (param1 param2) 
    (car '(test function heellooo)))
    #+END_SRC
*** let
    Allows the definition of local variables. The variables are only accessible
    in the body of the let function, after the variable definitions. The whole
    list of declared variables is surrounded by parens, as well as each
    individual variable definitions.
    #+begin_src Lisp
    (let ((a 5)
    (b 6))
    (+ a b))
    #+end_src
*** flet
    Allows the definition of local functions in very much the same way as the let
    function. The list of functions is surrounded by parens, and so is each
    individual function definition.

    The functions can only be used within the body of the flet function, and
    cannot reference each other or themselves. To do that, you need [[labels]].
    #+begin_src Lisp
    ;; single function
    (flet ((f (n)
    (+ n 10)))
    (f 5))
    ;; multiple functions
    (flet ((f (n)
    (+ n 10))
    (g (n)
    (* n 2)))
    (g (f 10)))
    #+end_src
*** labels
    Allows the definition of local functions. The difference from [[flet]] is that
    local functions can call each other or themselves.
    #+begin_src Lisp
    (labels ((a (n)
    (+ n 5))
    (b (n)
    (+ (a n) 6)))
    (b 10))
    #+end_src
** list functions
*** cons
    Two pieces of data can be linked with this, regardless of type. This
    allocates a cons cell which holds two references to the things being
    linked. Usually, the second item linked is a list.
    #+begin_src Lisp
    (cons 'cat 'dog)
    #+end_src
    The above links the =cat= and =dog= together. In the REPL, this link is
    represented by a =.= in between the two symbols, like =(CAT . DOG)=.
    
    The =nil= symbol is special, as it is a list terminator. Consing anything
    with a =nil= on the right hand side results in a list.
    #+begin_src Lisp
    (cons 'cat 'nil)
    #+end_src
    The above results in a list which contains just =cat=. Lisp hides cons cells
    as much as possible, preferring to display things as lists.

    The function also allows you to add things to the front of a list.
    #+begin_src Lisp
    (cons 'cat '(dog rabbit))
    #+end_src
    
    All lists are constructed from linked cons cells, so what the above is
    actually doing is:
    #+begin_src Lisp
    (cons 'cat (cons 'dog (cons 'rabbit 'nil)))
    #+end_src

    /A chain of cons cells and a list are the same thing!/
*** car
    This retrieves the item in the first slot of a cell, or the head of a given
    list; =(car '(cat dog rabbit))= would give you =cat=.
    
*** cdr
    This retrieves the item in the second slot of a cell, or the list without
    its first element; =(cdr '(cat dog rabbit))= would give you =(dog rabbit)=.
*** c****r
    The =car= and =cdr= functions can be strung together up to depth 4 to create a
    convenient list access function. For example, rather than applying =cdr= and
    then =car= to a list to access the second element, you can simply apply
    =cadr=.
    #+begin_src Lisp
    (car (cdr '(cat dog rabbit)))
    ;; is equivalent to 
    (cadr '(cat dog rabbit))
    #+end_src
*** list
    Creates a list from a series of symbols.
    #+begin_src Lisp
    (list 'cat 'dog 'rabbit)
    ;; is equivalent to...
    (cons 'cat (cons 'dog (cons 'rabbit ())))
    ;; is equivalent to
    '(cat dog rabbit)
    #+end_src
** other functions
*** progn
    Used often in =if= statements when more than one thing has to be done in a
    branch. Only the last evaluation in the expression is returned as the value
    of the whole expression. Basically, it allows you to do multiple things in a
    single expression and only return the value of the last thing.
    #+begin_src Lisp
    (defvar *was-odd* nil)
    (if (oddp 5)
    ;; doing two things!
    (progn (setf *was-odd* t)
	   'odd)
    'even)
    #+end_src
*** apply
*** remove-if-not
*** assoc
* syntax
** conditionals
Conditional commands are often [[special form]]s, which means that they do not have
to evaluate all their parameters.
*** if
    Can be used to do different things when the condition is true, or to check
    whether a list is empty.
    #+begin_src Lisp
    ;; evaluates to 'yes
    (if (= (+ 1 3) 4)
        'yes
        'no)
    ;; evaluates to 'no
    (if (= (+ 1 2) 4)
        'yes
        'no)
    ;; evaluates to 'empty
    (if '()
        'non-empty
        'empty)
    ;; evaluates to 'non-empty
    (if '(1)
        'non-empty
        'empty)
    #+end_src
    *important:*
    1. Only one of the expressions after the =if= is evaluated!
    2. It is only possible to do one thing in an =if= (no long extra
       computations!)
    
    Because =if= is a special form, it does not have to execute all of its
    parameters. This can lead to problems, for example:
    #+begin_src Lisp
    (if (oddp 5)
        'odd
        (/ 1 0))
    #+end_src
    The second branch does not have to be evaluated, and so a glaring error can
    be completely ignored.

    In a plain =if=, you can only do one thing, that is, you cannot have more
    than one expression being evaluated. In order to do so, you must use
    [[progn]]
*** when, unless
These conditionals can be used to evaluate multiple expressions without having
to use a =progn= like with =if=. However, they do not have the ability to do
anything when the condition is evaluated the opposite to what is required; =nil=
is returned.
**** when
    Enclosed expressions are evaluated when the condition is *true*.
    #+begin_src Lisp
    (defvar *was-odd* nil)
    (when (oddp 5)
      ;; doing multiple things without progn!
      (setf *was-odd* t)
      'odd)
    #+end_src
**** unless
    Enclosed expression are evaluated when the condition is *false*.
    #+begin_src Lisp
    (defvar *was-odd* nil)
    (unless (oddp 4)
      ;; doing multiple things without progn!
      (setf *was-odd* t)
      'odd)
    #+end_src
*** cond
    Allows the execution of a number of branches, with implicit =progn=. The
    classic Lisp conditional.
    #+begin_src Lisp
    (defun num-test (n)
    (cond ((= n 5) (+ 10 2) '(it's five))
	  ((oddp n) (+ 3 5) '(it's odd))
	  (t (* 2 3) '(it's boring))))
    #+end_src
    The branches are separated by parens, and the first item in each set of
    parens is the condition for that branch. Conditions are checked from the top
    down. The =t= at the end guarantees that the last branch will be executed,
    which is a common way of using =cond=.
*** case
    Implicitly uses =eq= to compare values against one that has been provided. 
    #+begin_src Lisp
    (defun name-test (name)
      (case name
        ((john) (+ 1 2) '(it was john))
        ((seb) (+ 1 3) '(it was seb))
        (otherwise '(i don't know who))))
    #+end_src
    =case= can be more efficient than =cond=, especially when there are a large
    number of conditions.
    *important:* =case= uses =eq= for comparison! This means that you cannot use
    it to compare some things (e.g. strings).
** true and false
   In Lisp, the only thing that evaluates to false is the empty list; /any value
   which is not equivalent to the empty list is true/.
   
   There are several aliases for the empty list =()=. They are =nil=, =\'nil=,
   and =\'()=, which can be confirmed by checking their equality:
   #+begin_src Lisp
   (eq '() nil)
   (eq '() ())
   (eq '() 'nil)
   #+end_src
   The first two things in this look weird, because they are not being treated
   as data (or so it seems). Actually, the language is made such that they both
   evaluate to the empty list. =nil= evaluates to itself, allowing omission of
   the quote, and =()= is a by-product of the way that empty forms are
   parsed. The last case works because =()= and =nil= should be treated the same
   according to the spec.

   There is some debate as to whether the empty list and falsity should be the
   same thing.
** equality
** special characters
*** '
    The single quote mark enters data mode. Anything in this mode will be treated
    as data and not as any type of command. This is called quoting.
*** #'
*** `
* terminology
** quasiquoting
   This is the term for a piece of code which uses the backtick to allow
   flipping between code and data mode.
   #+begin_src Lisp
   `(one plus one is ,(+ 1 1) and three squared is ,(expt 3 2))
   #+end_src
** special form
   A special form is a function which has some special privileges, which
   includes:
   1. Not having to evaluate all of its parameters (e.g. if)
      
