* functions
** math functions
*** expt
    Exponentiation to a specific power.
    #+begin_src Lisp
    ;; 2^3 = 8
    (expt 2 3)
    #+end_src
*** exp
    Exponentiation with base e.
    #+begin_src Lisp
    ;; e^2 = 7.389056
    (exp 2)
    #+end_src
*** ash
    Arithmetic shift.
    #+BEGIN_SRC Lisp
    ;; shift left (=20)
    (ash 10 1)
    ;; shift right (=5)
    (ash 10 -1)
    #+END_SRC
*** oddp
    True if a number is odd
    #+begin_src Lisp
    ;; evaluates to T
    (oddp 1)
    ;; evaluates to nil
    (oddp 2)
    #+end_src
*** evenp
    True if a number is even
    #+begin_src Lisp
    ;; evaluates to nil
    (evenp 1)
    ;; evaluates to T
    (evenp 2)
    #+end_src
** definition functions
*** defparameter
    Allows the definition of global variables. By convention, global variable
    names are surrounded by *, known as /earmuffs/, so that they are easier
    to distinguish from local variables.
    
    Any value that was previously stored in the variable is overwritten. See
    [[defvar]] for a way to do it without overwriting.
    #+BEGIN_SRC Lisp
    ;; Defining a new parameter
    (defparameter *glob* 10)
    ;; Overwriting the parameter
    (defparameter *glob* 5)
    #+END_SRC
*** defvar
    Allows the definition of global variables, but does not overwrite previous
    values if they already exist.
    
    [[defparameter]] allows the overwriting of the value in global variables.
    #+BEGIN_SRC Lisp
    ;; Defining a new parameter
    (defvar *glob* 10)
    ;; attempting to overwrite (*glob* is still 5)
    (defvar *glob* 5)
    #+END_SRC
*** defun
    Allows the definition of a function.
    #+BEGIN_SRC Lisp
    (defun func (param1 param2) 
    (car '(test function heellooo)))
    #+END_SRC
*** let
    Allows the definition of local variables. The variables are only accessible
    in the body of the let function, after the variable definitions. The whole
    list of declared variables is surrounded by parens, as well as each
    individual variable definitions.
    #+begin_src Lisp
    (let ((a 5)
    (b 6))
    (+ a b))
    #+end_src
*** flet
    Allows the definition of local functions in very much the same way as the let
    function. The list of functions is surrounded by parens, and so is each
    individual function definition.

    The functions can only be used within the body of the flet function, and
    cannot reference each other or themselves. To do that, you need [[labels]].
    #+begin_src Lisp
    ;; single function
    (flet ((f (n)
    (+ n 10)))
    (f 5))
    ;; multiple functions
    (flet ((f (n)
    (+ n 10))
    (g (n)
    (* n 2)))
    (g (f 10)))
    #+end_src
*** labels
    Allows the definition of local functions. The difference from [[flet]] is that
    local functions can call each other or themselves.
    #+begin_src Lisp
    (labels ((a (n)
    (+ n 5))
    (b (n)
    (+ (a n) 6)))
    (b 10))
    #+end_src
** list functions
*** cons
    Two pieces of data can be linked with this, regardless of type. This
    allocates a cons cell which holds two references to the things being
    linked. Usually, the second item linked is a list.
    #+begin_src Lisp
    (cons 'cat 'dog)
    #+end_src
    The above links the =cat= and =dog= together. In the REPL, this link is
    represented by a =.= in between the two symbols, like =(CAT . DOG)=.
    
    The =nil= symbol is special, as it is a list terminator. Consing anything
    with a =nil= on the right hand side results in a list.
    #+begin_src Lisp
    (cons 'cat 'nil)
    #+end_src
    The above results in a list which contains just =cat=. Lisp hides cons cells
    as much as possible, preferring to display things as lists.

    The function also allows you to add things to the front of a list.
    #+begin_src Lisp
    (cons 'cat '(dog rabbit))
    #+end_src
    
    All lists are constructed from linked cons cells, so what the above is
    actually doing is:
    #+begin_src Lisp
    (cons 'cat (cons 'dog (cons 'rabbit 'nil)))
    #+end_src

    /A chain of cons cells and a list are the same thing!/
*** car
    This retrieves the item in the first slot of a cell, or the head of a given
    list; =(car '(cat dog rabbit))= would give you =cat=.
    
*** cdr
    This retrieves the item in the second slot of a cell, or the list without
    its first element; =(cdr '(cat dog rabbit))= would give you =(dog rabbit)=.
*** c****r
    The =car= and =cdr= functions can be strung together up to depth 4 to create a
    convenient list access function. For example, rather than applying =cdr= and
    then =car= to a list to access the second element, you can simply apply
    =cadr=.
    #+begin_src Lisp
    (car (cdr '(cat dog rabbit)))
    ;; is equivalent to 
    (cadr '(cat dog rabbit))
    #+end_src
*** list
    Creates a list from a series of symbols.
    #+begin_src Lisp
    (list 'cat 'dog 'rabbit)
    ;; is equivalent to...
    (cons 'cat (cons 'dog (cons 'rabbit ())))
    ;; is equivalent to
    '(cat dog rabbit)
    #+end_src
*** member
    Returns the element and subsequent list if the queried element is a member.
    #+begin_src Lisp
    ;; returns '(1 4 5)
    (member 1 '(2 3 1 4 5))
    #+end_src
*** find-if
    Finds the first value in a list for which a given function evaluates to
    true.
    #+begin_src Lisp
    (find-if #'oddp '(2 4 6 5 2 4))    
    #+end_src
*** append
    Joins several lists into a single one.
    #+begin_src Lisp
    (append '(hi) '(my name is) '(kurt))
    #+end_src
*** find
    Search a list for an item, and return the item.
    #+begin_src Lisp
    (find 'cat '(dog car cat rabbit))
    #+end_src
*** push
    Add an element to the front of an existing list.
    #+begin_src Lisp
    (defparameter *items* '(dog car truck rabbit))
    (push 'cat *items*)
    #+end_src
** alist functions
*** assoc
    Returns the /first/ key-value pair in an alist which matches the given key.
    #+begin_src Lisp
    (defparameter *colours* '((red primary)
			      (blue primary)
			      (green primary)
			      (purple (not primary))))
    (assoc 'red *colours*)
    #+end_src
** command line interaction
*** print
    Allows the printing of stuff to the console, with a newline at the end, and
    a space after the value. The value of the statement is the thing being
    printed, a side effect of which is that things will be printed twice in the
    REPL.
    #+begin_src Lisp
    (print '(cat dog mousse))
    #+end_src
    Almost everything in Lisp can be printed with this function, with minimal
    loss, such that they can be read back in using the =read= function.
*** prin1
    The same as print, but with no newline.
*** princ
    Tries to print things in a form that humans would prefer (i.e. without
    quotation marks and other extraneous bits). Can be used to generate any
    arbitrary bit of text, unlike print, which is limited by its printing
    objects so that they can be read back in.
*** read
    Reads input from the user from the REPL. Returned to the program when return
    is pressed.
    #+begin_src Lisp
    (defun hi ()
	   (print "type something:")
	   (let ((words (read)))
	     (print "you typed: ")
	     (print words)))
    #+end_src
    Can read practically anything that is a lisp structure - this means that it
    can read stuff from files if it was output in the correct form.
*** read-line
    Reads a line, treating whatever was entered as a string.
    #+begin_src 
    (defun say-hello ()
	   (princ "please type your name:")
	   (let ((name (read-line)))
		 (princ "nice to meet you,")
		 (princ name)))
    #+end_src
** other functions
*** mapcar
    Takes a function and a list, and applies the function to every member of the
    list, creating a new list containing the function return values.
    #+begin_src Lisp
    (mapcar #'exp '(1 3 5 7 9))
    #+end_src
*** progn
    Used often in =if= statements when more than one thing has to be done in a
    branch. Only the last evaluation in the expression is returned as the value
    of the whole expression. Basically, it allows you to do multiple things in a
    single expression and only return the value of the last thing.
    #+begin_src Lisp
    (defvar *was-odd* nil)
    (if (oddp 5)
    ;; doing two things!
    (progn (setf *was-odd* t)
	   'odd)
    'even)
    #+end_src
*** apply
    Given a function and a list of objects, it will apply the function to each
    separate object in the list.
    #+begin_src Lisp
    (apply #'append '((cheese) (is really rather) (tasty I believe)))
    #+end_src
    Can have problems with very long lists. Use =call-arguments-limit= variable
    to see what it is.
*** remove-if-not
    Removes every item from a list which does not return true for a given
    function.
    #+begin_src Lisp
    (remove-if-not #'oddp '(1 2 3 4 5 6 7 8 9))
    #+end_src
*** eval
    Allows the execution of data as code.
    #+begin_src Lisp
    (defparameter *sum* '(+ 2 3))
    (eval *sum*)
    #+end_src
    Do not overuse this! There are times when macros are more appropriate.
*** concatenate
    Can be used to concatenate lists or strings.
    #+begin_src Lisp
    (concatenate 'string "hi " "i'm" " going to a party")
    (concatenate 'list '(demons are present) '(in the fun) '(house))
    #+end_src
*** quote
    Used to add a quote to the start of something. =\'foo= and =(quote foo)= are
    equivalent.
    #+begin_src Lisp
    (append '(time) '(is null))
    ;; broken because list is not quoted
    ;(append '(time) (is null))
    ;; the quote function adds a quote, the append works
    (append '(time) (quote (is null)))
    #+end_src
* structures
** association list
   Also known as an alist. Associates data with a lookup key. Can find a value
   in an alist by using the assoc function.
   #+begin_src Lisp
   (defparameter *colours* '((red primary)
			     (blue primary)
			     (green primary)
			     (purple (not primary))))
   (assoc 'red *colours*)
   #+end_src
* syntax
** conditionals
Conditional commands are often [[special form]]s, which means that they do not have
to evaluate all their parameters.
*** if
    Can be used to do different things when the condition is true, or to check
    whether a list is empty.
    #+begin_src Lisp
    ;; evaluates to 'yes
    (if (= (+ 1 3) 4)
        'yes
        'no)
    ;; evaluates to 'no
    (if (= (+ 1 2) 4)
        'yes
        'no)
    ;; evaluates to 'empty
    (if '()
        'non-empty
        'empty)
    ;; evaluates to 'non-empty
    (if '(1)
        'non-empty
        'empty)
    #+end_src
    *important:*
    1. Only one of the expressions after the =if= is evaluated!
    2. It is only possible to do one thing in an =if= (no long extra
       computations!)
    
    Because =if= is a special form, it does not have to execute all of its
    parameters. This can lead to problems, for example:
    #+begin_src Lisp
    (if (oddp 5)
        'odd
        (/ 1 0))
    #+end_src
    The second branch does not have to be evaluated, and so a glaring error can
    be completely ignored.

    In a plain =if=, you can only do one thing, that is, you cannot have more
    than one expression being evaluated. In order to do so, you must use
    [[progn]]
*** when, unless
These conditionals can be used to evaluate multiple expressions without having
to use a =progn= like with =if=. However, they do not have the ability to do
anything when the condition is evaluated the opposite to what is required; =nil=
is returned.
**** when
    Enclosed expressions are evaluated when the condition is *true*.
    #+begin_src Lisp
    (defvar *was-odd* nil)
    (when (oddp 5)
      ;; doing multiple things without progn!
      (setf *was-odd* t)
      'odd)
    #+end_src
**** unless
    Enclosed expression are evaluated when the condition is *false*.
    #+begin_src Lisp
    (defvar *was-odd* nil)
    (unless (oddp 4)
      ;; doing multiple things without progn!
      (setf *was-odd* t)
      'odd)
    #+end_src
*** cond
    Allows the execution of a number of branches, with implicit =progn=. The
    classic Lisp conditional.
    #+begin_src Lisp
    (defun num-test (n)
    (cond ((= n 5) (+ 10 2) '(it's five))
	  ((oddp n) (+ 3 5) '(it's odd))
	  (t (* 2 3) '(it's boring))))
    #+end_src
    The branches are separated by parens, and the first item in each set of
    parens is the condition for that branch. Conditions are checked from the top
    down. The =t= at the end guarantees that the last branch will be executed,
    which is a common way of using =cond=.
*** case
    Implicitly uses =eq= to compare values against one that has been provided. 
    #+begin_src Lisp
    (defun name-test (name)
      (case name
        ((john) (+ 1 2) '(it was john))
        ((seb) (+ 1 3) '(it was seb))
        (otherwise '(i don't know who))))
    #+end_src
    =case= can be more efficient than =cond=, especially when there are a large
    number of conditions.

    *important:* =case= uses =eq= for comparison! This means that you cannot use
    it to compare some things (e.g. strings).
** true and false
   In Lisp, the only thing that evaluates to false is the empty list; /any value
   which is not equivalent to the empty list is true/.
   
   There are several aliases for the empty list =()=. They are =nil=, =\'nil=,
   and =\'()=, which can be confirmed by checking their equality:
   #+begin_src Lisp
   (eq '() nil)
   (eq '() ())
   (eq '() 'nil)
   #+end_src
   The first two things in this look weird, because they are not being treated
   as data (or so it seems). Actually, the language is made such that they both
   evaluate to the empty list. =nil= evaluates to itself, allowing omission of
   the quote, and =()= is a by-product of the way that empty forms are
   parsed. The last case works because =()= and =nil= should be treated the same
   according to the spec.

   There is some debate as to whether the empty list and falsity should be the
   same thing.
** equality
*** eq
    Used to compare symbols with other symbols.

    Can also compare conses, but returns true only if a cons is compared
    directly to itself.
    #+begin_src Lisp
    ;; preferred way of comparing symbols
    (eq 'cat 'cat)
    #+end_src
*** equal
    Used to compare things which look the same. If unsure about which equality
    to use, use this one.
    #+begin_src Lisp
    ;; lists
    (equal '(1 2 3) (cons 1 (cons 2 (cons 3 nil)))))
    (equal '(1 2 3) '(1 2 3))
    ;; symbols
    (equal 'cat 'cat)
    #+end_src
*** eql
    Similar to eq, but also does number and character comparisons.
*** equalp
    Essentially the same as equals, but handles string with different
    capitalisation, and can compare floating point numbers with integers.
*** specific data types
    =\== is used to compare numbers
    
    =string-equal= is for strings
    
    =char-equal= is for characters
** special characters
*** '
    The single quote mark enters data mode. Anything in this mode will be treated
    as data and not as any type of command. This is called quoting.
*** #'
    A shortcut for the =function= operator. Allows the direct referencing of a
    function, ensuring that it is not confused with local variable names.
    #+begin_src Lisp
    ;; these two are equivalent
    (mapcar (function exp) '(1 3 5))
    (mapcar #'exp '(1 3 5))
    #+end_src
*** `
    Enters data mode, but allows flipping between data and code mode using a
    comma. Called quasiquoting.
    #+begin_src Lisp
    `(2 + 1 is ,(+ 2 1) and 3 + 1 is ,(+ 3 1))
    #+end_src
* terminology
** quasiquoting
   This is the term for a piece of code which uses the backtick to allow
   flipping between code and data mode.
   #+begin_src Lisp
   `(one plus one is ,(+ 1 1) and three squared is ,(expt 3 2))
   #+end_src
** special form
   A special form is a function which has some special privileges, which
   includes:
   1. Not having to evaluate all of its parameters (e.g. if)
      
** higher order function
   A function that accepts another function as an argument, e.g. =mapcar=.
* concepts
** stealth conditionals
    The =and= and =or= functions can be used to do clean conditionals due to the
    fact that Lisp uses shortcut boolean evaluation, along with their more usual
    function.
**** and
     Evaluates to true if all the symbols passed to it are true.
     #+begin_src Lisp
     (and (oddp 1) (oddp 3) (oddp 5))
     #+end_src
     An example of cleaner conditionals because of the use of =and=:
     #+begin_src Lisp
     ;; Basic conditional - quite cumbersome
     (if (*file-modified)
         (if (ask-about-save)
             (save-file)))
     ;; better conditional
     (and (*file-modified*) (ask-about-save) (save-file))
     ;; best of both
     (if (and (*file-modified*)
	      (ask-about-save))
	 (save-file))
     #+end_src
     In the first case, the standard conditional works, but is a little bit
     cumbersome. The second, better one is a lot cleaner, and does exactly the
     same thing. There is, however, the problem that =(save-file)= does more
     than just returning true or false, and that might not be obvious. The third
     case is the best of both, where only expressions that specifically return a
     boolean are used in the conditional.
**** or
     Evaluates to true if at least one of the symbols passed to it is true.
     #+begin_src Lisp
     (or (oddp 1) (oddp 4) (oddp 8))
     #+end_src
     An example of the use of =or= as a conditional:
     #+begin_src Lisp
     ;; set the parameter to t only if the parameter is even.
     (defparameter *ev* nil)
     (or (oddp 4) (setf *ev* t)) 
     #+end_src
     Since =(oddp 4)= evaluates to false, execution continues to the next, so
     the variable is set. If the value used was 5, then the or would stop after
     finding that the value of =(oddp 5)= was true.
** rich return values
   Because of the way Lisp deals with truth and falsity, functions can return
   more than just the truth. A good example is the =member= function, which
   instead of just returning true or false, returns the member and subsequent
   members in the list. The additional benefit of this is that it allows the
   function to search for =nil= elements and still evaluate to true.

   Another function which benefits from this is =find-if=, which returns the
   first element of a list for which a given function evaluates to true. This
   allows it to be used both for conditionals, and also to retrieve values.   

** predicates
   Functions which return true or false values are called predicates. Such
   functions often have the =-p= suffix to indicate this, for example
   =is-flag-set-p=.
** keyword parameters
   Some functions take keyword parameters which allow access to some built in
   features.
   #+begin_src Lisp
   ;; finds elements in the list where the cadr value is 'y
   (find 'y '((3 x) (4 y) (5 z)) :key #'cadr)
   #+end_src
   Keyword parameters have two parts.
   1. The name, which begins with a colon (e.g. =:key=)
   2. The value
** code and data symmetry
   Program code and data can be treated interchangeably in Lisp. This is called
   /homoiconicity/.
   
   A simple example of the homoiconicity is with code and data mode, but it goes
   deeper than this. Raw code stored inside a variable can be executed with the
   =eval= function.
   #+begin_src Lisp
   (defparameter *sum* '(+ 2 3))
   (eval *sum*)
   #+end_src
* idioms
** push/assoc idiom
   Pushing new items onto a list without removing previous ones seems a bit
   weird. For example, in the text game, pushing an object onto the object list
   again rather than removing or changing the location when the player picks it
   up. When =assoc= is used, however, it always looks at the first key in the
   list that matches, and so it seems almost as though the previous copy of the
   object has been removed, where in fact it is still retained, keeping a
   history of all the old values.
* REPL
** customisation
   A REPL is easily customised by using some combination of the =read=, =eval=,
   =print=, and =loop= functions. A basic REPL:
   #+begin_src Lisp
   (defun repl ()
     (loop (print (eval (read)))))
   #+end_src
